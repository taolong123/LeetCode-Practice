# Task02:动态规划

 动态规划常常适用于**有重叠子问题**和**最优子结构**性质的问题，动态规划方法**所耗时间往往远少于朴素解**

**法**。

**主要思想**

```sql
若要解一个给定问题，我们需要解其不同部分(即子问题)，再根据子问题的解以得出原问题的解。动
态规划往往用于优化递归问题，例如斐波那契数列，如果运用递归的方式来求解会重复计算很多相同的
子问题，利用动态规划的思想可以减少计算量。
动态规划法仅仅解决每个子问题一次，具有天然剪枝的功能，从而减少计算量，
一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。
```

**动态规划模板步骤:**

确定动态规划状态 写出状态转移方程(画出状态转移表) 考虑初始化条件
 考虑输出状态 考虑对时间，空间复杂度的优化(Bonus)

**例题详解**

接下来，我们对每个步骤进行详细的讲解，并给出不同题目中考虑的不同方式，争取让大家吃透动态规 划的套路。
 我们以最经典的动态规划题目——Leetcode 300.最长上升子序列 为例子。

**题目描述**

给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例:

说明:

```
解题思路
第一步:确定动态规划状态
```

是否存在状态转移? 什么样的状态比较好转移，找到对求解问题最方便的状态转移?

想清楚到底是直接用需要求的，比如长度作为dp保存的变量还是用某个判断问题的状态比如是否 是回文子串来作为方便求解的状态

|       |                                                              |
| ----- | ------------------------------------------------------------ |
| 1 2 3 | 输入: [10,9,2,5,3,7,101,18]  输出: 4  解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 |
|       |                                                              |

|      |                                                              |
| ---- | ------------------------------------------------------------ |
| 1 2  | 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 你算法的时间复杂度应该为 O(n2) 。 |
|      |                                                              |

该题目可以直接用一个一维数组 来存储转移状态， 可以定义为以 这个数结尾的 最长递增子序列的长度。举个实际例子，比如在 nums[10,9,2,5,3,7,101,18] 中， dp[0] 表示 数字10的最长递增子序列长度，那就是本身，所以为1，对于 dp[5] 对应的数字7来说的最长递增 子序列是 [2,5,7] (或者 [2,3,7] )所以 dp[5]=3 。

**第二步:写出一个好的状态转移方程** 使用**数学归纳法**思维，写出准确的状态方程

比如还是用刚刚那个 nums 数组，我们**思考一下是如何得到 的**:既然是递增的子序列， 我们只要找到nums[5] (也就是7)前面那些结尾比7小的子序列，然后把7接到最后，就可以形成一 个新的递增的子序列，也就是这个新的子序列也就是在找到的前面那些数后面加上7，相当长度加 1。当然可能会找到很多不同的子序列，比如刚刚在上面列举的，但是只需要找到长度最长的作为

dp[5] 的值就行。总结来说就是比较当前 dp[i] 的长度和 dp[i] 对应产生新的子序列长度，我们 用 j 来表示所有比 i 小的组数中的索引，可以用如下代码公式表示

**Tips:** 在实际问题中，如果不能很快得出这个递推公式，可以先尝试一步一步把前面几步写出来， 如果还是不行很可能就是 dp 数组的定义不够恰当，需要回到第一步重新定义 dp 数组的含义;或 者可能是 dp 数组存储的信息还不够，不足以推出下一步的答案，需要把 dp 数组扩大成二维数组 甚至三维数组。

**第三步:考虑初始条件**

```
 这是决定整个程序能否跑通的重要步骤，当我们确定好状态转移方程，我们就需要考虑一下边界值，
边界值考虑主要又分为三个地方:
```

**第四步:考虑输出状态**

主要有以下三种形式，对于具体问题，我们一定要想清楚到底dp数组里存储的是哪些值，最后我们需要 的是数组中的哪些值:

返回dp数组中最后一个值作为输出，一般对应二维dp问题。 返回dp数组中最大的那个数字，一般对应记录最大值问题。 返回保存的最大值，一般是 Maxval=max(Maxval,dp[i]) 这样的形式。

**Tips**:这个公式必须是在满足递增的条件下，也就是 nums[i]>nums[j] 的时候才能成立，并不是 nums[i] 前面所有数字都满足这个条件的，理解好这个条件就很容易懂接下来在输出时候应该是 max(dp) 而不是 dp[-1] ，原因就是dp数组由于计算递增的子序列长度，所以dp数组里中间可能 有值会是比最后遍历的数值大的情况，每次遍历 nums[j] 所对应的位置都是比 nums[i] 小的那个

数。举个例子，比如 nums=[1,3,6,7,9,4,10,5,6] ,而最后 dp=[1,2,3,4,5,3,6,4,5] 。 总结一下，最后的结果应该返回dp数组中值最大的数。